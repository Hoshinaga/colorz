#! /usr/bin/env ruby
# coding: utf-8
# 
# colorz
#   Complex domain coloring
# Usage: colorz [options] FUNCTION
# Options:
#   -s XxY
#   -r MIN,MAX
#   -o OUTPUT_FILE

require "cmath"
require "chunky_png"
require "rgb"
require "optparse"

include Math

class DomainColoring

  attr_accessor :width, :height, :min_r, :min_i, :max_r, :max_i

  def initialize(options)
    @width = options[:width]
    @height = options[:height]
    @min_r, @max_r = min_max(options[:min_r], options[:max_r])
    @min_i, @max_i = min_max(options[:min_i], options[:max_i])
  end

  def min_max(a, b)
    if a <= b
      [a, b]
    else
      [b, a]
    end
  end
  
  def intensity(r)
    if r == 0
      r
    else
      log_2 = log2(r)
      log_2 -= log_2.floor
    end
  end

  def grid(z)
    real = sin(z.real * PI).abs
    imag = sin(z.imag * PI).abs
    grid = [real, imag].min
    grid = [log(grid) / log(200), -1.0].max
    grid = 1.0 - grid * grid
    
    return grid
  end

  def pulse(x)
    log_sq = [log(sqrt(x)), -1.0].max
    pulse = log_sq*log_sq
    
    return pulse
  end

  def comp_to_hsl(z)
    radius, theta = z.polar
    h = 0.5 * theta / PI
    r = intensity(radius)
    s = sqrt(sqrt(sin(r * PI)))
    l = [0.5 * grid(z) * (2.0 - s) + pulse(s), 1.0].min

    return [h, s, l]
  end

  def complex_function(script)
    extend CMath
    zfunc = eval <<-EOS
      lambda do |z|
        result = #{script}
        result = Complex.rect(0, result.imag) if result.real.to_f.nan?
        result = Complex.rect(result.real, 0) if result.imag.to_f.nan?
        return result
      end
    EOS
  end
  
  def plot(script)
    zfunc = complex_function(script)
    
    png = ChunkyPNG::Image.new(@width, @height, ChunkyPNG::Color::TRANSPARENT)
    @height.times do |y|
      imag = @max_i - y*(@max_i - @min_i)/@height
      @width.times do |x|
        real = @min_r + x*(@max_r - @min_r)/@width
        z = Complex.rect(real, imag)
        comp = zfunc.call(z)
        h, s, l = comp_to_hsl(comp)
        r, g, b = RGB::Color.from_fractions(h, s, l).to_rgb
        png[x, y] = ChunkyPNG::Color.rgb(r, g, b)
      end
    end
    
    return png
  end

end #class


class ColorZ

  DEFAULT_WIDTH = 400
  DEFAULT_HEIGHT = 400
  DEFAULT_FUNTION = "z"

  def opt_parse(argv)
    opts = {}
    
    OptionParser.new do |opt|
      begin
        opt.version = '0.1.0'
        opt.banner = "Complex domain coloring\n" + opt.banner
        opt.banner += " FUNCTION"
        opt.separator("\nOptions:")
        opt.on('-s=WxH', '--size',
          'size(width=W, height=H) of the output image') {|v| opts[:s] = v}
        opt.on('-r=MIN,MAX', '--range',
          'coloring range (e.g. -r=-2-2i,+2+2i)') {|v| opts[:r] = v}
        opt.on('-o=OUTPUT_FILE', '--out',
          'file path of output image') {|v| opts[:o] = v}

        opt.parse!(ARGV)
      rescue => e
        $stderr.puts "ERROR: #{e}.\n#{opt}"
        exit
      end
    end
    
    return opts
  end

  def main(argv)
    opts = opt_parse(argv)
    
    size = opts[:s]
    if size
      width, height = size.split("x").map {|n| n.to_i}
    else
      width, height = DEFAULT_WIDTH, DEFAULT_HEIGHT
    end
    
    range = opts[:r]
    if range
      min, max = range.split(",").map {|s| s.to_c} 
      min_r = min.real.to_f
      min_i = min.imag.to_f
      max_r = max.real.to_f
      max_i = max.imag.to_f
    else
      min_r = -4.0
      min_i = -4.0
      max_r = +4.0
      max_i = +4.0
    end
    
    out = opts[:o]
    if out
      output_file = out
    else
      output_file = "colorz.png"
    end
    
    dom_color = DomainColoring.new(
    {
      min_r: min_r,
      min_i: min_i,
      max_r: max_r,
      max_i: max_i,

      width: width,
      height: height
    })
    
    script = argv.join(" ")
    script = DEFAULT_FUNTION if script.empty?
    png = dom_color.plot(script)
    png.save(output_file)
    
    puts File.expand_path(output_file)
  end # main
  
end # class


#################################

ColorZ.new.main(ARGV)

exit 0

# EOF
